[[plugins]] # complement LSP
repo = 'j-hui/fidget.nvim'
rev = 'v1.*'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local fidget = require("fidget")

fidget.setup()

EOF
'''

# [[plugins]] # show status line
# repo = 'vim-airline/vim-airline'
# on_event = "VimEnter"
# depends = ['vim-fugitive']
# hook_source = '''
# let g:airline#extensions#coc#enabled = 1
# set laststatus=2
# let g:airline_powerline_fonts = 0
# let g:airline#extensions#tabline#enabled = 1
# let airline#extensions#coc#error_symbol = 'E:'
# let airline#extensions#coc#warning_symbol = 'W:'
#
# if !exists('g:airline_symbols')
#   let g:airline_symbols = {}
# endif
# "
# let g:airline_symbols.crypt = 'É¦'
# let g:airline_symbols.paste = 'Ï'
# let g:airline_symbols.spell = 'êž¨'
# '''

[[plugins]] # show status line
repo = 'nvim-lualine/lualine.nvim'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local function hasKey(table, key)
    return table[key] ~= nil
end

local lualine = require('lualine')

-- Color table for highlights
local c = require('onedark.colors')
local cfg = vim.g.onedark_config

local colors = {
    black = c.bg0,
    white = c.fg,
    red = c.red,
    green = c.green,
    yellow = c.yellow,
    orange = c.orange,
    blue = c.blue,
    purple = c.purple,
    cyan = c.cyan,
    grey = c.grey,
    light_grey = c.light_grey,
    bg1 = c.bg1,
    bg2 = c.bg2,
    bg3 = c.bg3,
    bg_d = c.bg_d,
}

local theme = {
  normal = {
    a = { fg = colors.black, bg = colors.green },
    b = { fg = colors.light_grey, bg = colors.bg3 },
    c = { fg = colors.white },
  },

  insert = { a = { fg = colors.black, bg = colors.blue, gui = 'bold' } },
  visual = { a = { fg = colors.black, bg = colors.purple, gui = 'bold' } },
  command = { a = { fg = colors.black, bg = colors.yellow, gui = 'bold' } },
  terminal = { a = { fg = colors.bg, bg = colors.cyan, gui = 'bold' } },
  replace = { a = { fg = colors.black, bg = colors.red, gui = 'bold' } },

  inactive = {
    a = { fg = colors.black, bg = colors.grey },
    b = { fg = colors.white, bg = colors.black },
    c = { fg = colors.white },
  },
}

local conditions = {
  buffer_not_empty = function()
    return vim.fn.empty(vim.fn.expand('%:t')) ~= 1
  end,
  hide_in_width = function()
    return vim.fn.winwidth(0) > 80
  end,
  check_git_workspace = function()
    local filepath = vim.fn.expand('%:p:h')
    local gitdir = vim.fn.finddir('.git', filepath .. ';')
    return gitdir and #gitdir > 0 and #gitdir < #filepath
  end,
}

-- Config
local config = {
  options = {
    globalstatus = false,
    -- Disable sections and component separators
    component_separators = '',
    section_separators = '',
    theme = theme,
  },
  sections = {
    -- these are to remove the defaults
    lualine_a = {},
    lualine_b = {},
    lualine_y = {},
    lualine_z = {},
    -- These will be filled later
    lualine_c = {},
    lualine_x = {},
  },
  inactive_sections = {
    -- these are to remove the defaults
    lualine_a = {},
    lualine_b = {},
    lualine_y = {},
    lualine_z = {},
    lualine_c = {},
    lualine_x = {},
  },
  -- winbar = {
  --   lualine_a = {},
  --   lualine_b = {'filename'},
  --   lualine_c = {'buffers'},
  --   lualine_x = {'tabs'},
  --   lualine_y = {},
  --   lualine_z = {}
  -- },
  extensions = {
      'quickfix',
      'mason',
      'nvim-tree',
  }
}

-- Inserts a component in lualine_c at left section
local function ins_left(loc, component)
  table.insert(loc, component)
end

-- Inserts a component in lualine_x at right section
local function ins_right(component)
  table.insert(config.sections.lualine_x, component)
end

ins_left(config.sections.lualine_a, {
  -- mode component
  'mode',
  padding = 1,
})

ins_left(config.sections.lualine_b, {
  'branch',
  shorting_target = 4,
  icon = 'ï‘¿',
  -- color = { fg = colors.purple},
  cond = conditions.hide_in_width,
})

ins_left(config.sections.lualine_c, {
  'filename',
  shorting_target = 32,
  cond = conditions.buffer_not_empty,
  -- color = { fg = colors.green, gui = 'bold' },
})

ins_left(config.sections.lualine_c, {
  'diagnostics',
  sources = { 'nvim_diagnostic' },
  diagnostics_color = {
    error = { fg = colors.red },
    warn = { fg = colors.yellow },
    info = { fg = colors.cyan },
    hint = { fg = colors.green },
  },
})

-- Insert mid section. You can make any number of sections in neovim :)
-- for lualine it's any number greater then 2
ins_left(config.sections.lualine_c, {
  function()
    return '%='
  end,
})

-- Add components to right sections
ins_right {
  'o:encoding', -- option component same as &encoding in viml
  fmt = string.upper, -- I'm not sure why it's upper case either ;)
  cond = conditions.hide_in_width,
  -- color = { fg = colors.green, gui = 'bold' },
}

ins_right {
  'filetype',
  cond = conditions.hide_in_width,
  icons_enabled = false,
  color = { fg = colors.green },
}


ins_right {
  'fileformat',
  fmt = string.upper,
  icons_enabled = false,
  -- color = { fg = colors.green, gui = 'bold' },
  cond = conditions.hide_in_width,
}

ins_right {
  'diff',
  -- Is it me or the symbol for modified us really weird
  symbols = { added = 'ïƒ¾ ', modified = 'ó°¤ ', removed = 'ï…† ' },
  diff_color = {
    added = { fg = colors.green },
    modified = { fg = colors.cyan },
    removed = { fg = colors.purple },
  },
  cond = conditions.hide_in_width,
}

ins_right {
  'progress',
  color = { fg = colors.white, gui = 'bold' },
  cond = conditions.hide_in_width,
}

ins_right {
  'location',
  color = { fg = colors.light_grey, bg = colors.bg3 },
}

-- Now don't forget to initialize lualine
require("lualine").setup(config)

EOF
'''

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]] # complement LSP
repo = 'jay-babu/mason-null-ls.nvim'
on_event = "VimEnter"
depends = ['mason.nvim']
hook_post_source = '''
lua << EOF

require("mason-null-ls").setup({
    ensure_installed = {
        "biome",
        "black",
        "goimports",
        "impl",
        "gomodifytags",
        "stylua",
        "isort",
        "markdownlint",
        "prettier",
        "textlint",
    },
})

EOF
'''

[[plugins]] # complement LSP
repo = 'nvimtools/none-ls.nvim'
on_event = "VimEnter"
depends = ['plenary.nvim', 'mason-null-ls.nvim']
hook_post_source = '''
lua << EOF

local null_ls = require("null-ls")
local augroup = vim.api.nvim_create_augroup("LspFormatting", {})

local disabled_format_clients = { "lua_ls", "volar", "tsserver" }

on_attach = function(client, bufnr)
    if client.supports_method("textDocument/formatting") then
        vim.api.nvim_clear_autocmds({ group = augroup, buffer = bufnr })
        vim.api.nvim_create_autocmd("BufWritePre", {
            group = augroup,
            buffer = bufnr,
            callback = function()
                vim.lsp.buf.format({
                    async = false,
                    filter = function(c)
                        -- return not vim.tbl_contains(disabled_format_clients, c.name)
                        return c.name == "null-ls"
                    end,
                    timeout_ms = 1000,
                })
            end,
        })
    end
end


null_ls.setup({
    on_attach = on_attach,
    sources = {
        null_ls.builtins.completion.spell.with({
            filetypes = {"text", "markdown", "tex", "latex"},
        }),
        null_ls.builtins.code_actions.gitsigns,
        null_ls.builtins.code_actions.gomodifytags,
        null_ls.builtins.code_actions.impl,
        -- null_ls.builtins.diagnostics.editorconfig_checker,
        null_ls.builtins.diagnostics.markdownlint,
        null_ls.builtins.diagnostics.textlint.with({
            condition = function(utils)
                return utils.root_has_file({ ".textlintrc" })
            end,
        }),
        null_ls.builtins.diagnostics.vint,
        null_ls.builtins.diagnostics.zsh,
        null_ls.builtins.formatting.biome,
        null_ls.builtins.formatting.black,
        null_ls.builtins.formatting.gofmt,
        null_ls.builtins.formatting.goimports,
        null_ls.builtins.formatting.isort,
        null_ls.builtins.formatting.markdownlint,
        null_ls.builtins.formatting.prettier.with({
            filetypes = {"vue", "css", "scss", "less", "html","yaml", "graphql", "handlebars"},
        }),
        null_ls.builtins.formatting.stylua,
        null_ls.builtins.formatting.textlint.with({
            condition = function(utils)
                return utils.root_has_file({ ".textlintrc" })
            end,
        }),
        null_ls.builtins.hover.dictionary,
    }
})

EOF
'''

# [[plugins]] # formatting on save config
# repo = 'lukas-reineke/lsp-format.nvim'
# on_event = "BufReadPost"
# hook_post_source = '''
# lua << EOF
#
# local lsp_format = require("lsp-format")
# local lsp_config = require("lspconfig")
#
# lsp_format.setup()
#
# local on_attach = function(client, bufnr)
#     lsp_format.on_attach(client, bufnr)
#
#     -- ... custom code ...
# end
#
# lsp_config.gopls.setup({ on_attach = on_attach })
# lsp_config.pyright.setup({ on_attach = on_attach })
#
# EOF
# '''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
rev = "v0.*"
merged = 0
on_event = 'BufEnter'
hook_post_update = 'TSUpdate'
hook_source = '''
lua << EOF

require'nvim-treesitter.configs'.setup {
  ensure_installed = {
    "bash",
    "c",
    "cmake",
    "comment",
    "cpp",
    "css",
    "dart",
    "diff",
    "dockerfile",
    "git_rebase",
    "go",
    "html",
    "javascript",
    "jq",
    "json",
    "jsonc",
    "latex",
    "lua",
    "make",
    "markdown",
    "markdown_inline",
    "python",
    "rust",
    "scss",
    "typescript",
    "toml",
    "vim",
    "vue",
    "yaml",
  },

  sync_install = false,
  auto_install = false,
  ignore_install = {},

  highlight = {
    enable = true,
    disable = function(lang, buf)
        local max_filesize = 100 * 1024 -- 100 KB
        local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
        if ok and stats and stats.size > max_filesize then
            return true
        end
    end,

    additional_vim_regex_highlighting = false,
  },
}

EOF
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-context'
on_event = 'BufEnter'
depends = ['nvim-treesitter']

[[plugins]]
repo = 'nvim-tree/nvim-web-devicons'

[[plugins]]
repo = 'nvim-telescope/telescope-fzf-native.nvim'
build = 'cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release && cmake --build build --config Release && cmake --install build --prefix build'

[[plugins]]
repo = 'nvim-telescope/telescope-file-browser.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope-symbols.nvim'

[[plugins]]
repo = 'tami5/sqlite.lua'

[[plugins]]
repo = 'nvim-telescope/telescope-frecency.nvim'
depends = ['sqlite.lua']

[[plugins]]
repo = 'fhill2/telescope-ultisnips.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope-ui-select.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
rev = 'v0.1.*'
depends = [
    # 'nvim-web-devicons',
    'plenary.nvim',
    'telescope-fzf-native.nvim',
    'telescope-file-browser.nvim',
    'telescope-frecency.nvim',
    'telescope-ui-select.nvim',
    'telescope-symbols.nvim',
    'telescope-ultisnips.nvim',
]
on_event = 'VimEnter'

hook_add = '''
nnoremap [telescope] <Nop>
nmap <C-p> [telescope]
nnoremap <silent> [telescope]f :Telescope find_files <CR>
nnoremap <silent> [telescope]F :Telescope find_files no_ignore=true<CR>
nnoremap <silent> [telescope]r :Telescope frecency <CR>
nnoremap <silent> [telescope]g :Telescope live_grep <CR>
nnoremap <silent> [telescope]v :Telescope git_files <CR>
nnoremap <silent> [telescope]b :Telescope buffers <CR>
nnoremap <silent> [telescope]j :Telescope jumplist <CR>
nnoremap <silent> [telescope]t :Telescope filetypes <CR>
nnoremap <silent> [telescope]y :Telescope registers <CR>
nnoremap <silent> [telescope]m :Telescope marks <CR>
nnoremap <silent> [telescope]q :Telescope command_history <CR>
nnoremap <silent> [telescope]H :Telescope help_tags <CR>
nnoremap <silent> [telescope]n :Telescope find_files cwd=$MY_NOTE_DIR <CR>
nnoremap <silent> [telescope]N :Telescope live_grep cwd=$MY_NOTE_DIR <CR>
" nnoremap <silent> [telescope]o :Telescope treesitter <CR>

nnoremap <silent> [telescope]c :Telescope git_commits <CR>
nnoremap <silent> [telescope]e :lua require('telescope.builtin').symbols{ sources = {'emoji', 'gitmoji'} } <CR>
nnoremap <silent> [telescope]o :Telescope file_browser <CR>

nnoremap <silent> [telescope]s :SessionManager load_current_dir_session<CR>
nnoremap <silent> [telescope]S :SessionManager load_session<CR>
'''

hook_post_source = '''
lua << EOF

local actions = require("telescope.actions")
local transform_mod = require("telescope.actions.mt").transform_mod
local action_state = require('telescope.actions.state')
local action_layout = require("telescope.actions.layout")
local fb_actions = require("telescope").extensions.file_browser.actions

-- multi open function
local function multiopen(prompt_bufnr, method)
  local edit_file_cmd_map = {
    vertical = "vsplit",
    horizontal = "split",
    tab = "tabedit",
    default = "edit",
  }
  local edit_buf_cmd_map = {
    vertical = "vert sbuffer",
    horizontal = "sbuffer",
    tab = "tab sbuffer",
    default = "buffer",
  }
  local picker = action_state.get_current_picker(prompt_bufnr)
  local multi_selection = picker:get_multi_selection()

  if #multi_selection > 1 then
    require("telescope.pickers").on_close_prompt(prompt_bufnr)
    pcall(vim.api.nvim_set_current_win, picker.original_win_id)

    for i, entry in ipairs(multi_selection) do
      local filename, row, col

      if entry.path or entry.filename then
        filename = entry.path or entry.filename

        row = entry.row or entry.lnum
        col = vim.F.if_nil(entry.col, 1)
      elseif not entry.bufnr then
        local value = entry.value
        if not value then
          return
        end

        if type(value) == "table" then
          value = entry.display
        end

        local sections = vim.split(value, ":")

        filename = sections[1]
        row = tonumber(sections[2])
        col = tonumber(sections[3])
      end

      local entry_bufnr = entry.bufnr

      if entry_bufnr then
        if not vim.api.nvim_buf_get_option(entry_bufnr, "buflisted") then
          vim.api.nvim_buf_set_option(entry_bufnr, "buflisted", true)
        end
        local command = i == 1 and "buffer" or edit_buf_cmd_map[method]
        pcall(vim.cmd, string.format("%s %s", command, vim.api.nvim_buf_get_name(entry_bufnr)))
      else
        local command = i == 1 and "edit" or edit_file_cmd_map[method]
        if vim.api.nvim_buf_get_name(0) ~= filename or command ~= "edit" then
          filename = require("plenary.path"):new(vim.fn.fnameescape(filename)):normalize(vim.loop.cwd())
          pcall(vim.cmd, string.format("%s %s", command, filename))
        end
      end

      if row and col then
        pcall(vim.api.nvim_win_set_cursor, 0, { row, col })
      end
    end
  else
    actions["select_" .. method](prompt_bufnr)
  end
end

local custom_actions = transform_mod({
    multi_selection_open_vertical = function(prompt_bufnr)
        multiopen(prompt_bufnr, "vertical")
    end,
    multi_selection_open_horizontal = function(prompt_bufnr)
        multiopen(prompt_bufnr, "horizontal")
    end,
    multi_selection_open_tab = function(prompt_bufnr)
        multiopen(prompt_bufnr, "tab")
    end,
    multi_selection_open = function(prompt_bufnr)
        multiopen(prompt_bufnr, "default")
    end,
})

local function stopinsert(callback)
    return function(prompt_bufnr)
        vim.cmd.stopinsert()
        vim.schedule(function()
            callback(prompt_bufnr)
        end)
    end
end

local multi_open_mappings = {
  i = {
    ["<M-v>"] = stopinsert(custom_actions.multi_selection_open_vertical),
    ["<M-s>"] = stopinsert(custom_actions.multi_selection_open_horizontal),
    ["<M-t>"] = stopinsert(custom_actions.multi_selection_open_tab),
    ["<CR>"]  = stopinsert(custom_actions.multi_selection_open),
  },
  n = {
    ["<M-v>"] = custom_actions.multi_selection_open_vertical,
    ["<M-s>"] = custom_actions.multi_selection_open_horizontal,
    ["<M-t>"] = custom_actions.multi_selection_open_tab,
    ["<CR>"] = custom_actions.multi_selection_open,
  },
}

require("telescope").setup {
  defaults = {
    mappings = {
      i = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<C-u>"] = actions.results_scrolling_up,
        ["<C-d>"] = actions.results_scrolling_down,
        ["<C-f>"] = actions.preview_scrolling_down,
        ["<C-b>"] = actions.preview_scrolling_up,
        ["<M-p>"] = action_layout.toggle_preview,
      },
      n = {
        ["j"] = actions.move_selection_next,
        ["k"] = actions.move_selection_previous,
        ["<C-u>"] = actions.results_scrolling_up,
        ["<C-d>"] = actions.results_scrolling_down,
        ["<C-f>"] = actions.preview_scrolling_down,
        ["<C-b>"] = actions.preview_scrolling_up,
        ["<M-p>"] = action_layout.toggle_preview,
      },
    },
    vimgrep_arguments = {
      'rg',
      '--no-heading',
      '--with-filename',
      '--line-number',
      '--column',
      '--hidden',
      '--smart-case',
      '--glob',
      '!**/node_modules/*',
      '--glob',
      '!**/.git/*',
      '--glob',
      '!.gitignore',
      '--glob',
      '!**/.venv/*',
      '--glob',
      '!**/*.lock',
      '--trim',
    },
    file_ignore_patterns = {"^node_modules/", "^./.git/", "^./.venv/"},
  },
  pickers = {
    find_files = {
      find_command = {
        'rg',
        '--files',
        '--hidden',
        '--smart-case',
        '--glob',
        '!**/node_modules/*',
        '--glob',
        '!**/.git/*',
        '--glob',
        '!**/.venv/*',
      },
      mappings = {
        i = {
          ["<M-v>"] = stopinsert(custom_actions.multi_selection_open_vertical),
          ["<M-s>"] = stopinsert(custom_actions.multi_selection_open_horizontal),
          ["<M-t>"] = stopinsert(custom_actions.multi_selection_open_tab),
          ["<CR>"]  = stopinsert(custom_actions.multi_selection_open),
        },
        n = {
          ["<M-v>"] = custom_actions.multi_selection_open_vertical,
          ["<M-s>"] = custom_actions.multi_selection_open_horizontal,
          ["<M-t>"] = custom_actions.multi_selection_open_tab,
          ["<CR>"] = custom_actions.multi_selection_open,
          ["cd"] = function(prompt_bufnr)
            local selection = require("telescope.actions.state").get_selected_entry()
            local dir = vim.fn.fnamemodify(selection.path, ":p:h")
            require("telescope.actions").close(prompt_bufnr)
            vim.cmd(string.format("silent cd %s", dir))
            vim.cmd(":Telescope find_files")
          end
        },
      },
    },
    buffers = {
        sort_mru = true,
        mappings = multi_open_mappings,
    },
    live_grep = {
        mappings = multi_open_mappings,
    },
  },
  extensions = {
    fzf = {
      fuzzy = true,
      override_generic_sorter = true,
      override_file_sorter = true,
      case_mode = "smart_case",
    },
    file_browser = {
      -- theme = "ivy",
      hidden = true,
      hijack_netrw = true,
      mappings = {
        i = {
          ["<M-v>"] = stopinsert(custom_actions.multi_selection_open_vertical),
          ["<M-s>"] = stopinsert(custom_actions.multi_selection_open_horizontal),
          ["<M-t>"] = stopinsert(custom_actions.multi_selection_open_tab),
          ["<CR>"]  = stopinsert(custom_actions.multi_selection_open),
          ["<M-h>"] = fb_actions.goto_parent_dir,
          ["<M-.>"] = fb_actions.toggle_hidden,
          ["<M-p>"] = fb_actions.change_cwd,
        },
        n = {
          ["<M-v>"] = custom_actions.multi_selection_open_vertical,
          ["<M-s>"] = custom_actions.multi_selection_open_horizontal,
          ["<M-t>"] = custom_actions.multi_selection_open_tab,
          ["<CR>"] = custom_actions.multi_selection_open,
          ["<M-h>"] = fb_actions.goto_parent_dir,
          ["<M-.>"] = fb_actions.toggle_hidden,
          ["<M-p>"] = fb_actions.change_cwd,
        },
      },
    },
    coc = {
      -- theme = 'ivy',
      prefer_locations = true,
    },
  },
}

require('telescope').load_extension('fzf')
require('telescope').load_extension('frecency')
require('telescope').load_extension('file_browser')
require('telescope').load_extension('ui-select')
require('telescope').load_extension('ultisnips')

EOF
'''

[[plugins]] # enable to do git operation in vim
repo = 'tpope/vim-fugitive'
on_event = 'VimEnter'
hook_add = '''
nnoremap [git]  <Nop>
nmap <Leader>g [git]
nnoremap <silent> [git]s :Git status<CR><C-w>T
nnoremap <silent> [git]a :Git write<CR>
nnoremap <silent> [git]c :Git commit<CR>
nnoremap <silent> [git]b :Git blame<CR>
nnoremap <silent> [git]d :Git diff<CR>
nnoremap <silent> [git]m :Git merge<CR>
'''

[[plugins]] # git-messenger shows message from last commit
repo = 'rhysd/git-messenger.vim'
on_event = 'VimEnter'
hook_add = '''
let g:git_messenger_no_default_mappings=v:true
nnoremap <silent> [git]gm :GitMessenger<CR>
'''

[[plugins]]
repo = 'sindrets/diffview.nvim'
depends = ['nvim-web-devicons']
on_event = 'VimEnter'
hook_post_source = '''
lua << EOF

require("diffview").setup({
  use_icons = false,
})

EOF

nnoremap <silent> [git]d :DiffviewOpen<CR>
'''

[[plugins]]
repo = 'lewis6991/gitsigns.nvim'
on_event = 'VimEnter'
hook_post_source = '''
lua << EOF

require("gitsigns").setup({
  on_attach = function(bufnr)
    local gs = package.loaded.gitsigns

    local function map(mode, l, r, opts)
      opts = opts or {}
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    -- Navigation
    map('n', ']h', function()
      if vim.wo.diff then return ']h' end
      vim.schedule(function() gs.next_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    map('n', '[h', function()
      if vim.wo.diff then return '[h' end
      vim.schedule(function() gs.prev_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    -- Actions
    map({'n', 'v'}, '<leader>hs', ':Gitsigns stage_hunk<CR>')
    map({'n', 'v'}, '<leader>hr', ':Gitsigns reset_hunk<CR>')
    map('n', '<leader>hS', gs.stage_buffer)
    map('n', '<leader>hu', gs.undo_stage_hunk)
    map('n', '<leader>hR', gs.reset_buffer)
    map('n', '<leader>hp', gs.preview_hunk)
    map('n', '<leader>hb', function() gs.blame_line{full=true} end)
    map('n', '<leader>hd', gs.diffthis)
    map('n', '<leader>hD', function() gs.diffthis('~') end)
    map('n', '<leader>hw', ':Gitsigns toggle_word_diff<CR>')
    map('n', '<leader>ht', gs.toggle_deleted)
  end
})

EOF
'''

# [[plugins]]
# repo = 'neoclide/coc.nvim'
# rev = "release"
# merged = 0
# on_event = 'VimEnter'
# hook_add = '''
# set nobackup
# set nowritebackup
# set updatetime=300
# set signcolumn=yes
#
# " change completion window behaviors
# inoremap <silent><expr> <TAB>
#       \ coc#pum#visible() ? coc#pum#next(1):
#       \ CheckBackspace() ? "\<Tab>" :
#       \ coc#refresh()
# inoremap <expr><S-TAB> coc#pum#visible() ? coc#pum#prev(1) : "\<C-h>"
# inoremap <silent><expr> <CR> coc#pum#visible() ? coc#pum#confirm()
#                               \: "\<C-g>u\<CR>\<c-r>=coc#on_enter()\<CR>"
#
# function! CheckBackspace() abort
#   let col = col('.') - 1
#   return !col || getline('.')[col - 1]  =~# '\s'
# endfunction
#
# augroup cocfunc
#   autocmd!
#   " Setup formatexpr specified filetype(s).
#   autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
#   " Update signature help on jump placeholder
#   autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
#
#   " format settings
#   autocmd BufWritePre *.py CocFormatBuf
#   "autocmd BufWritePre *.go :call CocAction('runCommand', 'editor.action.organizeImport')
#   autocmd BufWritePre *.go CocFormatBuf
#
# augroup end
#
# " Highlight symbol under cursor on CursorHold
# autocmd CursorHold * silent call CocActionAsync('highlight')
#
# " Use `:CocFormatBuf` to format current buffer
# command! -nargs=0 CocFormatBuf :call CocAction('format')
#
# " Add status line support, for integration with other plugin, checkout `:h coc-status`
# " set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}
# set statusline^=%{coc#status()}
#
# " coc keymaps
# nmap [coc] <Nop>
# map <C-k> [coc]
# " nmap <silent> [coc]a :<C-u>CocAction<cr>
# nmap <silent> [coc]a     :Telescope coc commands<cr>
# nmap <silent> [coc]F :<C-u>CocFormatBuf<cr>
# nmap <silent> [coc]f     <Plug>(coc-format-selected)
# xmap <silent> [coc]f     <Plug>(coc-format-selected)
# nmap <silent> [coc]p     <Plug>(coc-diagnostic-prev)
# nmap <silent> [coc]n     <Plug>(coc-diagnostic-next)
# nmap <silent> [coc]x     <Plug>(coc-fix-current)
# nmap <silent> [coc]d     :<C-u>CocList diagnostics<cr>
# " nmap <silent> [coc]d     :Telescope coc diagnostics<cr>
# nmap <silent> [coc]r     <Plug>(coc-rename)
# nmap <silent> [coc]h     <Plug>(coc-codeaction)
# nmap <silent> [coc]o     :<C-u>CocList outline<cr>
# nmap <silent> [coc]y     :<C-u>CocList -I symbols<cr>
#
# nmap <silent> [coc]<C-d> :call <SID>show_documentation()<CR>
#
# nmap <silent> gd <Plug>(coc-definition)
# nmap <silent> gh :call CocAction('doHover')<cr>
# nmap <silent> gy <Plug>(coc-type-definition)
# nmap <silent> gi <Plug>(coc-implementation)
# nmap <silent> gr <Plug>(coc-references)
#
# " Remap <C-f> and <C-b> for scroll float windows/popups.
# if has('nvim-0.4.0') || has('patch-8.2.0750')
#   nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
#   nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
#   inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
#   inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
#   vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
#   vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
# endif
#
# "imap <C-l> <Plug>(coc-snippets-expand)
# "vmap <C-j> <Plug>(coc-snippets-select)
# "let g:coc_snippet_next = '<c-j>'
# "let g:coc_snippet_prev = '<c-k>'
# "imap <C-j> <Plug>(coc-snippets-expand-jump)
#
# function! s:show_documentation()
#   if (index(['vim','help'], &filetype) >= 0)
#     execute 'h '.expand('<cword>')
#   elseif (coc#rpc#ready())
#     call CocActionAsync('doHover')
#   else
#     execute '!' . &keywordprg . " " . expand('<cword>')
#   endif
# endfunction
# '''

[[plugins]]
repo = 'rlane/pounce.nvim'
on_event = 'VimEnter'
hook_add = '''
noremap [motion] <Nop>
map <S-m> [motion]

nmap [motion] <cmd>Pounce <CR>
vmap [motion] <cmd>Pounce <CR>
omap [motion] <cmd>Pounce <CR>
'''
hook_post_source = '''
lua << EOF

require("pounce").setup({
  accept_keys = "JFKDLSAHGNUVRBYTMICEOXWPQZ",
  accept_best_key = "<enter>",
  multi_window = true,
  debug = false,
})

EOF
'''

[[plugins]]
repo = 'SirVer/ultisnips'
on_event = 'VimEnter'
hook_source = '''
" let g:UltiSnipsExpandTrigger = "<C-e>"
" let g:UltiSnipsJumpForwardTrigger = "<C-j>"
" let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
let g:UltiSnipsEditSplit = "vertical"
let g:UltiSnipsSnippetDirectories = ["~/.config/dotfiles/snippets"]

let g:ultisnips_python_style = "google"
'''

[[plugins]]
repo = 'honza/vim-snippets'
on_event = 'VimEnter'
depends = ['ultisnips']

# [[plugins]] # Auto close parentheses
# repo = 'cohama/lexima.vim'
# on_event = 'VimEnter'
# hook_add = '''
# "call lexima#add_rule({'char': '$', 'input_after': '$', 'filetype': 'latex'})
# "call lexima#add_rule({'char': '$', 'at': '\%#\$', 'leave': 1, 'filetype': 'latex'})
# "call lexima#add_rule({'char': '<BS>', 'at': '\$\%#\$', 'delete': 1, 'filetype': 'latex'})
# '''

[[plugins]] # enable to buffer execution on vim
repo = 'thinca/vim-quickrun'
on_event = 'VimEnter'
hook_add = '''
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
      \ 'runner' : 'vimproc',
      \ 'outputter/buffer/split' : ':botright 8sp',
      \ 'outputter' : 'error',
      \ 'outputter/error/success' : 'buffer',
      \ 'outputter/error/error' : 'quickfix',
      \ 'outputter/buffer/close_on_empty' : 1,
      \ }

let g:quickrun_config.rust = {
      \ 'exec' : 'cargo run',
      \ }

let g:quickrun_config.go = {
      \ 'exec' : 'go run .',
      \ }

let g:quickrun_no_default_key_mappings = 1

nnoremap <Leader>r :cclose<CR>:write<CR>:QuickRun<CR>
xnoremap <Leader>r :<C-U>cclose<CR>:write<CR>gv:QuickRun -mode v<CR>

autocmd FileType qf nnoremap <silent><buffer>q :quit<CR>

" \r: save and execute quickrun (excluding go file type)
" autocmd Filetype * if &ft!="go"|nnoremap <buffer> <Leader>r :cclose<CR>:write<CR>:QuickRun -mode n<CR>|endif

" nnoremap \r :cclose<CR>:write<CR>:QuickRun -mode n<CR>
" xnoremap \r :<C-U>cclose<CR>:write<CR>gv:QuickRun -mode v<CR>

" C-c: stop quickrun
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "<Leader><C-c>"
'''

# [[plugins]] # Neovim/Vim integration for Delve
# repo = 'sebdah/vim-delve'
# on_event = 'VimEnter'
# on_ft = 'go'
# hook_add = '''
# autocmd FileType go nnoremap <Leader>d :DlvDebug<CR>
# autocmd FileType go nnoremap <Leader>p :DlvToggleBreakpoint<CR>
# '''

[[plugins]] # get file type for Shougo-san's plugins
repo = 'Shougo/context_filetype.vim'
on_event = 'VimEnter'

[[plugins]] # swhitch buffer file type according to cursor position
repo = 'osyo-manga/vim-precious'
depends = ['context_filetype.vim']
on_event = 'VimEnter'
hook_add ='''
'''

[[plugins]] # enhance text object
repo = 'tpope/vim-surround'
on_event = 'VimEnter'

[[plugins]] # highlights trailing whitespace
repo = 'bronson/vim-trailing-whitespace'
on_event = 'VimEnter'
hook_add = '''
let g:extra_whitespace_ignored_filetypes = [
            \ 'help',
            \ 'diff',
            \ 'TelescopePrompt',
            \ 'Telescope'
            \ ]
autocmd BufWritePre * :FixWhitespace
'''

[[plugins]] # plugin for alignment words
repo = 'h1mesuke/vim-alignta'
on_event = 'VimEnter'
on_cmd = 'Alignta'

[[plugins]] # a plugin for using web-api in vim
repo = 'mattn/webapi-vim'

[[plugins]] # for using gist services
repo = 'mattn/gist-vim'
depends = ['webapi-vim']
on_cmd = 'Gist'

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
on_event = 'VimEnter'
hook_post_source = '''
lua << EOF

vim.opt.listchars:append "space:â‹…"
vim.opt.listchars:append "eol:â†´"

require("ibl").setup {
    scope = {
        show_start = false,
        show_end = false,
    },
}

EOF
'''

[[plugins]] # auto insert space around '=' & ','
repo = 'kana/vim-smartchr'
on_event = 'InsertCharPre'
hook_add = '''
" inoremap <expr> , smartchr#loop(', ', ',')
" inoremap <expr> . smartchr#loop('.', '. ', '..', '...')
inoremap <expr> = smartchr#loop('=', ' = ', ' == ', ' === ')
" inoremap <expr> ! smartchr#loop('!', '!!', ' != ')
" inoremap <expr> : smartchr#loop(':', '::', ' := ')
" inoremap <expr> + smartchr#loop('+', ' + ', '++')
" inoremap <expr> - smartchr#loop('-', ' - ', '--')
" inoremap <expr> * smartchr#loop('*', ' * ')
" inoremap <expr> / smartchr#loop('/', ' / ', '// ')
" inoremap <expr> & smartchr#loop('&', ' & ', ' && ')
" inoremap <expr> | smartchr#loop('|', ' | ', ' || ')
'''

[[plugins]] # comment out / decomment plugin
repo = 'numToStr/Comment.nvim'
on_event = 'VimEnter'
hook_post_source = '''
lua << EOF

require('Comment').setup({
  mappings = {
    basic = true,
    extra = true,
  }
})

EOF
'''

[[plugins]] # for enabling display & edit binary file in vim
repo = 'Shougo/vinarise.vim'
on_cmd = 'Vinarise'
hook_add = 'let g:vinarise_enable_auto_detect = 1'

[[plugins]] # for sorting python file import line, command ':PyImportSort!'
repo = 'tweekmonster/impsort.vim'
on_ft = 'py'
on_cmd = 'PyImportSort'
hook_source = 'let g:impsort_highlight_imported = 0'

[[plugins]] # for url open in browser & search word
repo = 'tyru/open-browser.vim'
on_map = ['<Plug>(openbrowser-smart-search)']
on_event = 'VimEnter'
hook_add = '''
nmap gs <Plug>(openbrowser-smart-search)
vmap gs <Plug>(openbrowser-smart-search)
'''

# [[plugins]] # set syntax highlights and commands for markdown
# repo = 'plasticboy/vim-markdown'
# on_ft = ['markdown','pandoc.markdown','rmd']
# on_event = 'BufEnter'
# hook_add = '''
# let g:vim_markdown_math = 1
# let g:vim_markdown_frontmatter = 1
# let g:vim_markdown_toml_frontmatter = 1
# let g:vim_markdown_json_frontmatter = 1
# let g:vim_markdown_conceal=0
# let g:vim_markdown_folding_disabled=1
# let g:vim_markdown_folding_style_pythonic = 1
# let g:vim_markdown_toc_autofit = 1
#
# autocmd Filetype markdown nnoremap gt :Toc<CR>
# '''

[[plugins]] # for the real-time preview for markdown files
repo = 'iamcco/markdown-preview.nvim'
on_ft = ['markdown','pandoc.markdown','rmd']
build = 'sh -c "cd app && yarn install"'

[[plugins]] # assist table edit on markdown files
repo = 'dhruvasagar/vim-table-mode'
on_ft = ['markdown','pandoc.markdown','rmd']
on_event = 'VimEnter'

[[plugins]] # Automated session manager
repo = 'Shatur/neovim-session-manager'
depends = ['plenary.nvim']
on_event = 'VimEnter'
hook_post_source = '''

lua << EOF

local Path = require('plenary.path')
require('session_manager').setup({
  autoload_mode = require('session_manager.config').AutoloadMode.Disabled, -- Define what to do when Neovim is started without arguments. Possible values: Disabled, CurrentDir, LastSession
  autosave_last_session = true, -- Automatically save last session on exit and on session switch.
  autosave_ignore_not_normal = true, -- Plugin will not save a session when no buffers are opened, or all of them aren't writable or listed.
  autosave_ignore_dirs = {
    "/",
    "~/",
  }, -- A list of directories where the session will not be autosaved.
  autosave_ignore_filetypes = { -- All buffers of these file types will be closed before the session is saved.
    'gitcommit',
  },
  autosave_only_in_session = true, -- Always autosaves session. If true, only autosaves after a session is active.
})

EOF
'''

[[plugins]] # call :Template to get template each file types
repo = 'mattn/sonictemplate-vim'
on_cmd = 'Template'

[[plugins]]
repo = 'glepnir/zephyr-nvim'
on_event = 'VimEnter'

[[plugins]] # set auto ambiwidth
repo = 'delphinus/cellwidths.nvim'
on_event = 'VimEnter'
hook_post_source = '''

lua << EOF

require("cellwidths").setup {
  name = "default",
}

EOF
'''

[[plugins]] # EditorConfig
repo = 'editorconfig/editorconfig-vim'
on_event = 'BufReadPre'
on_path = '.*'

[[plugins]] # indent based folding and motion
repo = 'pseewald/vim-anyfold'
on_event = 'BufEnter'
hook_add = '''
filetype plugin indent on
syntax on

" activate anyfold by default
augroup anyfold
    autocmd!
    autocmd Filetype * AnyFoldActivate
augroup END

" disable anyfold for large files
let g:LargeFile = 1000000 " file is large if size greater than 1MB
autocmd BufReadPre,BufRead * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
function LargeFile()
    augroup anyfold
        autocmd! " remove AnyFoldActivate
        autocmd Filetype * setlocal foldmethod=indent " fall back to indent folding
    augroup END
endfunction
" autocmd Filetype * AnyFoldActivate

set foldlevel=20
'''

# [[plugins]] # accelerate up-down moving
# repo = 'rhysd/accelerated-jk'
# on_event = 'BufEnter'
# hook_add = '''
# nmap j <Plug>(accelerated_jk_gj)
# nmap k <Plug>(accelerated_jk_gk)
# '''

[[plugins]] # logging command output
repo = 'tyru/capture.vim'
on_event = 'VimEnter'

[[plugins]] # file visualizer
repo = 'nvim-tree/nvim-tree.lua'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local nvim_tree = require("nvim-tree")

nvim_tree.setup()

EOF
'''

[[plugins]] # pretty quickfix, location view
repo = 'yorickpeterse/nvim-pqf'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local pqf = require("pqf")

pqf.setup({
})

EOF
'''

[[plugins]] # autopairs
repo = 'windwp/nvim-autopairs'
on_event = "VimEnter"
depends = ["nvim-cmp"]
hook_post_source = '''
lua << EOF

local npairs = require("nvim-autopairs")

local Rule = require('nvim-autopairs.rule')
local cond = require('nvim-autopairs.conds')
local ts_conds = require('nvim-autopairs.ts-conds')

local cmp_autopairs = require("nvim-autopairs.completion.cmp")
local handlers = require("nvim-autopairs.completion.handlers")

local cmp = require("cmp")

npairs.setup({
  check_ts = true,
  ts_config = {
    -- lua = {'string'},
    -- python = {},
  },
  ignored_next_char = "[%w%.]", -- will ignore alphanumeric and `.` symbol
})

-- add custom rules

npairs.add_rule(Rule("$$","$$","tex"))

-- press % => %% only while inside a comment or string
-- npairs.add_rules({
--   Rule("%", "%", "lua")
--     :with_pair(ts_conds.is_ts_node({'string','comment'})), -- not working in this cond?
--   Rule("$", "$", "lua")
--     :with_pair(ts_conds.is_not_ts_node({'function'}))
-- })


cmp.event:on(
  'confirm_done',
  cmp_autopairs.on_confirm_done({
    filetypes = {
      -- "*" is a alias to all filetypes
      ["*"] = {
        ["("] = {
          kind = {
            cmp.lsp.CompletionItemKind.Function,
            cmp.lsp.CompletionItemKind.Method,
          },
          handler = handlers["*"]
        }
      },
      -- lua = {
      --   ["("] = {
      --     kind = {
      --       cmp.lsp.CompletionItemKind.Function,
      --       cmp.lsp.CompletionItemKind.Method
      --     },
      --     ---@param char string
      --     ---@param item table item completion
      --     ---@param bufnr number buffer number
      --     ---@param rules table
      --     ---@param commit_character table<string>
      --     handler = function(char, item, bufnr, rules, commit_character)
      --       -- Your handler function. Inspect with print(vim.inspect{char, item, bufnr, rules, commit_character})
      --     end
      --   }
      -- },
      -- Disable for tex
      tex = false,
      text = false,
    }
  })
)

EOF
'''

[[plugins]] # git conflict support plugin
repo = 'akinsho/git-conflict.nvim'
rev = "v*"
on_event = "BufReadPost"
hook_post_source = '''
lua << EOF

require("git-conflict").setup()

EOF
'''

[[plugins]] # jump outlines
repo = 'hedyhli/outline.nvim'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

require("outline").setup({
  symbol_folding = {
    auto_unfold = {
      only = 2,
    },
  },
  preview_window = {
    auto_preview = true,
  },
})

EOF

" set outline.nvim keymap as a part of Telescope commands
nmap <C-p> [telescope]
nnoremap <silent> [telescope]h :Outline<CR>

'''

[[plugins]] # jump outlines
repo = 'nvimdev/lspsaga.nvim'
on_event = "VimEnter"
depends = ['nvim-treesitter', 'nvim-web-devicons']
hook_post_source = '''
lua << EOF

require("lspsaga").setup({
  symbol_in_winbar = {
    enable = false,
    show_server_name = false,
    show_file = false,
  },
  finder = {
    enable = false,
  },
  code_action = {
    extend_gitsigns = true,
  },
  lightbulb = {
    enable = false,
  },
})

-- add lspsaga keymaps instead of native lsp functions
vim.keymap.set('n', '[lsp]n', "<cmd>Lspsaga diagnostic_jump_next<CR>", opts)
vim.keymap.set('n', '[lsp]p', "<cmd>Lspsaga diagnostic_jump_prev<CR>", opts)
vim.keymap.set('n', '[lsp]d', "<cmd>Lspsaga show_buf_diagnostics<CR>", opts)
vim.keymap.set('n', '[lsp]D', "<cmd>Lspsaga show_workspace_diagnostics<CR>", opts)
vim.keymap.set('n', '[lsp]h', "<cmd>Lspsaga hover_doc<CR>", opts)
vim.keymap.set('n', '[lsp]a', "<cmd>Lspsaga code_action<CR>", opts)

EOF

'''

[[plugins]] # make a bookmarks
repo = 'tomasky/bookmarks.nvim'
on_event = "VimEnter"
depends = ['telescope.nvim']
hook_post_source = '''

nnoremap [bookmark]  <Nop>
nmap <Leader>b [bookmark]

lua << EOF

require("bookmarks").setup({
  sign_priority = 8,  --set bookmark sign priority to cover other sign
  save_file = vim.fn.expand "$HOME/.config/nvim/bookmarks", -- bookmarks save file path
  keywords =  {
    ["@t"] = "âœ…", -- mark annotation startswith @t,signs this icon as `Todo`
    ["@w"] = "âš ï¸" , -- mark annotation startswith @w arn,signs this icon as `Warn`
    ["@f"] = "â›ï¸", -- mark annotation startswith @f ix,signs this icon as `Fix`
    ["@n"] = "ðŸ—’ï¸" , -- mark annotation startswith @n ote,signs this icon as `Note`
  },
  on_attach = function(bufnr)
    local bm = require "bookmarks"
    local map = vim.keymap.set
    map("n","[bookmark]t",bm.bookmark_toggle) -- add or remove bookmark at current line
    map("n","[bookmark]a",bm.bookmark_ann) -- add or edit mark annotation at current line
    map("n","[bookmark]e",bm.bookmark_ann) -- add or edit mark annotation at current line
    map("n","[bookmark]cl",bm.bookmark_clean) -- clean all marks in local buffer
    map("n","[bookmark]n",bm.bookmark_next) -- jump to next mark in local buffer
    map("n","[bookmark]p",bm.bookmark_prev) -- jump to previous mark in local buffer
    -- map("n","ml",bm.bookmark_list) -- show marked file list in quickfix window
  end
})

require('telescope').load_extension('bookmarks')

EOF

" set keymaps
nnoremap <silent> [bookmark]t :Git status<CR><C-w>T
nnoremap <silent> [bookmark]e :Git write<CR>

nnoremap <silent> [telescope]B :Telescope bookmarks list <CR>
'''

[[plugins]] # showin top bar
repo = 'akinsho/bufferline.nvim'
rev = "v4.*"
on_event = "VimEnter"
depends = ['nvim-web-devicons']
hook_post_source = '''
lua << EOF

local bufferline = require("bufferline")

bufferline.setup({
  options = {
    style_preet = bufferline.style_preset.minimal,
    diagnostics = "nvim_lsp",
    diagnostics_indicator = function(count, level, diagnostics_dict, context)
      local icon = level:match("error") and "ïœ " or "ï± "
      return " " .. icon .. count
    end,
  },
})

EOF
'''

[[plugins]] # highlight any words
repo = 't9md/vim-quickhl'
on_event = "BufReadPre"
hook_add = '''
nmap <Leader>hl <Plug>(quickhl-manual-this)
xmap <Leader>hl <Plug>(quickhl-manual-this)
nmap <Leader>hc <Plug>(quickhl-manual-reset)
xmap <Leader>hc <Plug>(quickhl-manual-reset)

'''

[[plugins]] # highlight todo comments
repo = 'folke/todo-comments.nvim'
rev = "v1.*"
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local c = require('onedark.colors')

require("todo-comments").setup({
  colors = {
    error = { c.red },
    warning = { c.yellow },
    info = { c.blue },
    hint = { c.green },
    default = {  c.green },
    test = {  c.purple }
  },
})

EOF
'''
