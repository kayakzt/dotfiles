# configuration wrapper for builtin LSP
[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = "VimEnter"
hook_add = '''
nmap [lsp] <Nop>
map <C-k> [lsp]

lua << EOF

vim.diagnostic.config({severity_sort = true})

-- Global mappings.
-- See `:help vim.diagnostic.*` for documentation on any of the below functions
-- vim.keymap.set('n', '[lsp]D', vim.diagnostic.open_float)
-- vim.keymap.set('n', '[lsp]n', vim.diagnostic.goto_next)
-- vim.keymap.set('n', '[lsp]p', vim.diagnostic.goto_prev)
-- vim.keymap.set('n', '[lsp]d', vim.diagnostic.setloclist)

-- Use LspAttach autocommand to only map the following keys
-- after the language server attaches to the current buffer
vim.api.nvim_create_autocmd('LspAttach', {
  group = vim.api.nvim_create_augroup('UserLspConfig', {}),
  callback = function(ev)
    -- Enable completion triggered by <c-x><c-o>
    vim.bo[ev.buf].omnifunc = 'v:lua.vim.lsp.omnifunc'

    -- Buffer local mappings.
    -- See `:help vim.lsp.*` for documentation on any of the below functions
    local opts = { buffer = ev.buf }
    vim.keymap.set('n', 'gD', vim.lsp.buf.definition, opts)
    -- vim.keymap.set('n', 'gh', vim.lsp.buf.hover, opts)
    vim.keymap.set('n', 'gi', vim.lsp.buf.implementation, opts)
    vim.keymap.set('n', '[lsp]D', vim.lsp.buf.declaration, opts)
    vim.keymap.set('n', '[lsp]s', vim.lsp.buf.signature_help, opts)
    -- vim.keymap.set('n', '<space>wa', vim.lsp.buf.add_workspace_folder, opts)
    -- vim.keymap.set('n', '<space>wr', vim.lsp.buf.remove_workspace_folder, opts)
    -- vim.keymap.set('n', '<space>wl', function()
    --   print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
    -- end, opts)
    vim.keymap.set('n', '[lsp]t', vim.lsp.buf.type_definition, opts)
    -- vim.keymap.set('n', '[lsp]r', vim.lsp.buf.rename, opts)
    -- vim.keymap.set({ 'n', 'v' }, '[lsp]a', vim.lsp.buf.code_action, opts)
    vim.keymap.set('n', '[lsp]R', vim.lsp.buf.references, opts)
    vim.keymap.set('n', '[lsp]f', function()
      vim.lsp.buf.format { async = true }
    end, opts)
  end,
})

EOF
'''

[[plugins]]
repo = 'SirVer/ultisnips'
hook_source = '''
" let g:UltiSnipsExpandTrigger = "<C-e>"
" let g:UltiSnipsJumpForwardTrigger = "<C-j>"
" let g:UltiSnipsJumpBackwardTrigger = "<C-k>"

let g:UltiSnipsEditSplit = "vertical"

let g:UltiSnipsSnippetDirectories = [
    \ $HOME."/.config/nvim/UltiSnips"
\ ]

let g:ultisnips_python_style = "google"
'''

[[plugins]]
repo = 'honza/vim-snippets'
on_event = 'InsertEnter'
depends = ['ultisnips']

# completion source plugin
[[plugins]]
repo = 'hrsh7th/cmp-nvim-lsp-signature-help'

[[plugins]]
repo = 'hrsh7th/cmp-cmdline'

[[plugins]]
repo = 'hrsh7th/cmp-calc'

[[plugins]]
repo = 'hrsh7th/cmp-path'

[[plugins]]
repo = 'hrsh7th/cmp-buffer'

[[plugins]]
repo = 'hrsh7th/cmp-git'

[[plugins]]
repo = 'quangnguyen30192/cmp-nvim-ultisnips'

# completion plugin
[[plugins]]
repo = 'hrsh7th/nvim-cmp'
on_event = 'InsertEnter'
depends = [
    'cmp-git',
    'cmp-calc',
    'cmp-path',
    'cmp-buffer',
    'cmp-cmdline',
    'ultisnips',
    'cmp-nvim-ultisnips',
    'cmp-nvim-lsp-signature-help',
]
hook_source = '''
lua << EOF

local cmp = require("cmp")
local cmp_ultisnips_mappings = require("cmp_nvim_ultisnips.mappings")

cmp.setup({
    snippet = {
        expand = function(args)
            vim.fn["UltiSnips#Anon"](args.body) -- for ultisnips users.
        end,
    },
    mapping = cmp.mapping.preset.insert({
        ['<Tab>'] = cmp.mapping.select_next_item({ behavior = cmp.SelectBehavior.Select }),
        ['<S-Tab>'] = cmp.mapping.select_prev_item({ behavior = cmp.SelectBehavior.Select }),
        ['<CR>'] = cmp.mapping.confirm({ select = true }),
        ['<C-b>'] = cmp.mapping.scroll_docs(-4),
        ['<C-f>'] = cmp.mapping.scroll_docs(4),
        ['<C-e>'] = cmp.mapping(
            function(fallback)
                cmp_ultisnips_mappings.expand_or_jump_forwards(fallback)
            end,
            { "i", "s", --[[ "c" (to enable the mapping in command mode) ]] }
        ),
    }),
    sources = cmp.config.sources({
        { name = 'nvim_lsp' },
        { name = 'nvim_lsp_signature_help' },
        { name = 'buffer' },
        { name = 'git' },
        { name = 'path' },
        { name = 'calc' },
        { name = 'ultisnips' },
    })
})

cmp.setup.cmdline({ '/', '?' }, {
    mapping = cmp.mapping.preset.cmdline(),
    sources = {
        { name = 'buffer' },
        { name = 'path' },
    }, {
        {
            name = 'cmdline',
            option = {
                ignore_cmds = { 'Man', '!' }
            }
        },
    }
})

cmp.setup.cmdline(':', {
    mapping = cmp.mapping.preset.cmdline(),
    sources = cmp.config.sources({
        { name = 'path' }
    }, {
        { name = 'cmdline' }
    }),
    matching = { disallow_symbol_nonprefix_matching = false }
})

require("cmp_git").setup()

EOF
'''

[[plugins]] # connect Native LSP to nvim-cmp
repo = 'hrsh7th/cmp-nvim-lsp'


# plaguin manager for neovim
[[plugins]]
repo = 'williamboman/mason.nvim'
depends = ['nvim-lspconfig']

# integrationg nvim-lspconfig and mason
[[plugins]]
repo = 'williamboman/mason-lspconfig.nvim'
on_event = "BufEnter"
depends = ['mason.nvim', 'cmp-nvim-lsp']
hook_source = '''
lua << EOF

local mason = require "mason"
local mason_lspconfig = require "mason-lspconfig"
local lspconfig = require "lspconfig"
local capabilities = require("cmp_nvim_lsp").default_capabilities()

local servers = {
    "bashls",
    "clangd",
    "dockerls",
    "gopls",
    "jsonls",
    "ts_ls",
    "pyright",
    "rust_analyzer",
    "taplo",
    "typos_lsp",
}

mason.setup({
    ui = {
        icons = {
            package_installed = "âœ“",
            package_pending = "âžœ",
            package_uninstalled = "âœ—"
        }
    }
})

mason_lspconfig.setup {
    ensure_installed = servers
}

require("mason-lspconfig").setup_handlers {
    function (server_name) -- default handler (optional)
        lspconfig[server_name].setup {
            capabilities = capabilities,
        }
        lspconfig.pyright.setup {
            settings = {
                python = {
                    venvPath = ".",
                    pythonPath = "./.venv/bin/python",
                    analysis = {
                        extraPaths = {"."},
                    },
                },
            },
        }
        lspconfig.typos_lsp.setup({
            init_options = {
                diagnosticSeverity = "Information",  -- change warning level
            },
        })
    end,
    -- ["rust_analyzer"] = function ()
    --     require("rust-tools").setup {}
    -- end
    -- if you want to use clippy diagnostic, see https://www.reddit.com/r/neovim/comments/nu2w2g/using_clippy_as_linter_for_rust_in/
}

EOF
'''

[[plugins]] # complement LSP
repo = 'j-hui/fidget.nvim'
rev = 'v1.*'
on_event = "BufEnter"
hook_source = '''
lua << EOF

local fidget = require("fidget")

fidget.setup()

EOF
'''

[[plugins]] # show status line
repo = 'nvim-lualine/lualine.nvim'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local function hasKey(table, key)
    return table[key] ~= nil
end

local lualine = require('lualine')

-- Color table for highlights
local c = require('onedark.colors')
local cfg = vim.g.onedark_config

local colors = {
    black = c.bg0,
    white = c.fg,
    red = c.red,
    green = c.green,
    yellow = c.yellow,
    orange = c.orange,
    blue = c.blue,
    purple = c.purple,
    cyan = c.cyan,
    grey = c.grey,
    light_grey = c.light_grey,
    bg1 = c.bg1,
    bg2 = c.bg2,
    bg3 = c.bg3,
    bg_d = c.bg_d,
}

local theme = {
  normal = {
    a = { fg = colors.black, bg = colors.green },
    b = { fg = colors.light_grey, bg = colors.bg3 },
    c = { fg = colors.white },
  },

  insert = { a = { fg = colors.black, bg = colors.blue } },
  visual = { a = { fg = colors.black, bg = colors.purple } },
  command = { a = { fg = colors.black, bg = colors.yellow } },
  terminal = { a = { fg = colors.bg, bg = colors.cyan } },
  replace = { a = { fg = colors.black, bg = colors.red } },

  inactive = {
    a = { fg = colors.black, bg = colors.grey },
    b = { fg = colors.white, bg = colors.black },
    c = { fg = colors.white },
  },
}

local conditions = {
  buffer_not_empty = function()
    return vim.fn.empty(vim.fn.expand('%:t')) ~= 1
  end,
  hide_in_width = function()
    return vim.fn.winwidth(0) > 80
  end,
  check_git_workspace = function()
    local filepath = vim.fn.expand('%:p:h')
    local gitdir = vim.fn.finddir('.git', filepath .. ';')
    return gitdir and #gitdir > 0 and #gitdir < #filepath
  end,
}

-- Config
local config = {
  options = {
    globalstatus = false,
    -- Disable sections and component separators
    component_separators = '',
    section_separators = '',
    theme = theme,
  },
  sections = {
    -- these are to remove the defaults
    lualine_a = {},
    lualine_b = {},
    lualine_y = {},
    lualine_z = {},
    -- These will be filled later
    lualine_c = {},
    lualine_x = {},
  },
  inactive_sections = {
    -- these are to remove the defaults
    lualine_a = {},
    lualine_b = {},
    lualine_y = {},
    lualine_z = {},
    lualine_c = {},
    lualine_x = {},
  },
  -- winbar = {
  --   lualine_a = {},
  --   lualine_b = {'filename'},
  --   lualine_c = {'buffers'},
  --   lualine_x = {'tabs'},
  --   lualine_y = {},
  --   lualine_z = {}
  -- },
  extensions = {
      'quickfix',
      'mason',
      'nvim-tree',
  }
}

-- Inserts a component in lualine_c at left section
local function ins_left(loc, component)
  table.insert(loc, component)
end

-- Inserts a component in lualine_x at right section
local function ins_right(component)
  table.insert(config.sections.lualine_x, component)
end

ins_left(config.sections.lualine_a, {
  -- mode component
  'mode',
  padding = 1,
})

ins_left(config.sections.lualine_b, {
  'branch',
  shorting_target = 4,
  icon = 'ï‘¿',
  -- color = { fg = colors.purple},
  cond = conditions.hide_in_width,
})

ins_left(config.sections.lualine_c, {
  'filename',
  shorting_target = 32,
  cond = conditions.buffer_not_empty,
  -- color = { fg = colors.green, gui = 'bold' },
})

ins_left(config.sections.lualine_c, {
  'diagnostics',
  sources = { 'nvim_diagnostic' },
  diagnostics_color = {
    error = { fg = colors.red },
    warn = { fg = colors.yellow },
    info = { fg = colors.cyan },
    hint = { fg = colors.purple },
  },
})

-- Insert mid section. You can make any number of sections in neovim :)
-- for lualine it's any number greater then 2
ins_left(config.sections.lualine_c, {
  function()
    return '%='
  end,
})

-- Add components to right sections
ins_right {
  'o:encoding', -- option component same as &encoding in viml
  fmt = string.upper, -- I'm not sure why it's upper case either ;)
  cond = conditions.hide_in_width,
  -- color = { fg = colors.green, gui = 'bold' },
}

ins_right {
  'filetype',
  cond = conditions.hide_in_width,
  icons_enabled = false,
  color = { fg = colors.green },
}


ins_right {
  'fileformat',
  fmt = string.upper,
  icons_enabled = false,
  -- color = { fg = colors.green, gui = 'bold' },
  cond = conditions.hide_in_width,
}

ins_right {
  'diff',
  -- Is it me or the symbol for modified us really weird
  symbols = { added = 'ïƒ¾ ', modified = 'ó°¤ ', removed = 'ï…† ' },
  diff_color = {
    added = { fg = colors.green },
    modified = { fg = colors.cyan },
    removed = { fg = colors.purple },
  },
  cond = conditions.hide_in_width,
}

ins_right {
  'progress',
  color = { fg = colors.white },
  cond = conditions.hide_in_width,
}

ins_right {
  'location',
  color = { fg = colors.light_grey, bg = colors.bg3 },
}

-- Now don't forget to initialize lualine
require("lualine").setup(config)

EOF
'''

[[plugins]]
repo = 'nvim-lua/plenary.nvim'

[[plugins]]
repo = 'MunifTanjim/nui.nvim'

[[plugins]] # complement LSP
repo = 'jay-babu/mason-null-ls.nvim'
on_event = "BufEnter"
depends = ['mason.nvim']
hook_source = '''
lua << EOF

require("mason-null-ls").setup({
    ensure_installed = {
        "biome",
        "black",
        "goimports",
        "impl",
        "gomodifytags",
        "stylua",
        "isort",
        "markdownlint",
        "prettier",
        "textlint",
        "shellcheck",
    },
})

EOF
'''

[[plugins]] # complement LSP
repo = 'nvimtools/none-ls.nvim'
on_event = "BufEnter"
depends = ['plenary.nvim', 'mason-null-ls.nvim']
hook_source = '''
lua << EOF

local null_ls = require("null-ls")
local augroup = vim.api.nvim_create_augroup("LspFormatting", {})

local disabled_format_clients = { "lua_ls", "volar", "tsserver" }

on_attach = function(client, bufnr)
    if client.supports_method("textDocument/formatting") then
        vim.api.nvim_clear_autocmds({ group = augroup, buffer = bufnr })
        vim.api.nvim_create_autocmd("BufWritePre", {
            group = augroup,
            buffer = bufnr,
            callback = function()
                vim.lsp.buf.format({
                    async = false,
                    filter = function(c)
                        -- return not vim.tbl_contains(disabled_format_clients, c.name)
                        return c.name == "null-ls"
                    end,
                    timeout_ms = 1000,
                })
            end,
        })
    end
end


null_ls.setup({
    on_attach = on_attach,
    sources = {
        null_ls.builtins.completion.spell.with({
            filetypes = {"text", "markdown", "tex", "latex"},
        }),
        null_ls.builtins.code_actions.gitsigns,
        null_ls.builtins.code_actions.gomodifytags,
        null_ls.builtins.code_actions.impl,
        -- null_ls.builtins.diagnostics.editorconfig_checker,
        null_ls.builtins.diagnostics.markdownlint,
        null_ls.builtins.diagnostics.textlint.with({
            condition = function(utils)
                return utils.root_has_file({ ".textlintrc" })
            end,
        }),
        null_ls.builtins.diagnostics.vint,
        null_ls.builtins.diagnostics.zsh,
        null_ls.builtins.formatting.biome,
        null_ls.builtins.formatting.black,
        null_ls.builtins.formatting.gofmt,
        null_ls.builtins.formatting.goimports,
        null_ls.builtins.formatting.isort,
        null_ls.builtins.formatting.markdownlint,
        null_ls.builtins.formatting.prettier.with({
            filetypes = {"vue", "css", "scss", "less", "html","yaml", "graphql", "handlebars"},
        }),
        null_ls.builtins.formatting.stylua,
        null_ls.builtins.formatting.textlint.with({
            condition = function(utils)
                return utils.root_has_file({ ".textlintrc" })
            end,
        }),
        null_ls.builtins.hover.dictionary,
    }
})

EOF
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
rev = "v0.*"
merged = 0
on_event = 'BufEnter'
hook_post_update = 'TSUpdate'
hook_source = '''
lua << EOF

require'nvim-treesitter.configs'.setup {
  ensure_installed = {
    "bash",
    "c",
    "cmake",
    "comment",
    "cpp",
    "css",
    "dart",
    "diff",
    "dockerfile",
    "git_rebase",
    "go",
    "html",
    "javascript",
    "jq",
    "json",
    "jsonc",
    "latex",
    "lua",
    "make",
    "markdown",
    "markdown_inline",
    "python",
    "rust",
    "scss",
    "typescript",
    "toml",
    "vim",
    "vue",
    "yaml",
  },

  sync_install = false,
  auto_install = false,
  ignore_install = {},

  highlight = {
    enable = true,
    disable = function(lang, buf)
        local max_filesize = 100 * 1024 -- 100 KB
        local ok, stats = pcall(vim.loop.fs_stat, vim.api.nvim_buf_get_name(buf))
        if ok and stats and stats.size > max_filesize then
            return true
        end
    end,

    additional_vim_regex_highlighting = false,
  },
}

EOF
'''

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter-context'
on_event = 'BufEnter'
depends = ['nvim-treesitter']

[[plugins]]
repo = 'nvim-tree/nvim-web-devicons'

[[plugins]]
repo = 'nvim-telescope/telescope-fzf-native.nvim'
build = 'cmake -S. -Bbuild -DCMAKE_BUILD_TYPE=Release && cmake --build build --config Release && cmake --install build --prefix build'

[[plugins]]
repo = 'nvim-telescope/telescope-file-browser.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope-symbols.nvim'

[[plugins]]
repo = 'tami5/sqlite.lua'

[[plugins]]
repo = 'nvim-telescope/telescope-frecency.nvim'
depends = ['sqlite.lua']

[[plugins]]
repo = 'fhill2/telescope-ultisnips.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope-ui-select.nvim'

[[plugins]]
repo = 'nvim-telescope/telescope.nvim'
rev = 'v0.1.*'
depends = [
    # 'nvim-web-devicons',
    'plenary.nvim',
    'telescope-fzf-native.nvim',
    'telescope-file-browser.nvim',
    'telescope-frecency.nvim',
    'telescope-ui-select.nvim',
    'telescope-symbols.nvim',
    'telescope-ultisnips.nvim',
]
on_event = 'VimEnter'

hook_add = '''
nnoremap [telescope] <Nop>
nmap <C-p> [telescope]
nnoremap <silent> [telescope]f :Telescope find_files <CR>
nnoremap <silent> [telescope]F :Telescope find_files no_ignore=true<CR>
nnoremap <silent> [telescope]r :Telescope frecency <CR>
nnoremap <silent> [telescope]g :Telescope live_grep <CR>
nnoremap [telescope]G :execute 'Telescope live_grep default_text=' . expand('<cword>')<cr>
nnoremap <silent> [telescope]v :Telescope git_files <CR>
nnoremap <silent> [telescope]b :Telescope buffers <CR>
nnoremap <silent> [telescope]j :Telescope jumplist <CR>
nnoremap <silent> [telescope]T :Telescope filetypes <CR>
nnoremap <silent> [telescope]y :Telescope registers <CR>
nnoremap <silent> [telescope]m :Telescope marks <CR>
nnoremap <silent> [telescope]q :Telescope command_history <CR>
nnoremap <silent> [telescope]H :Telescope help_tags <CR>
nnoremap <silent> [telescope]n :Telescope find_files cwd=$MY_NOTE_DIR <CR>
nnoremap <silent> [telescope]N :Telescope live_grep cwd=$MY_NOTE_DIR <CR>
" nnoremap <silent> [telescope]o :Telescope treesitter <CR>

nnoremap <silent> [telescope]c :Telescope git_commits <CR>
nnoremap <silent> [telescope]e :lua require('telescope.builtin').symbols{ sources = {'emoji', 'gitmoji'} } <CR>
nnoremap <silent> [telescope]o :Telescope file_browser <CR>

nnoremap <silent> [telescope]s :SessionManager load_current_dir_session<CR>
nnoremap <silent> [telescope]S :SessionManager load_session<CR>

nnoremap <silent> [telescope]t :TodoTelescope<CR>
'''

hook_post_source = '''
lua << EOF

local telescope = require("telescope")
local actions = require("telescope.actions")
local transform_mod = require("telescope.actions.mt").transform_mod
local action_state = require('telescope.actions.state')
local action_layout = require("telescope.actions.layout")
local fb_actions = require("telescope").extensions.file_browser.actions

-- multi open function
local function multiopen(prompt_bufnr, method)
  local edit_file_cmd_map = {
    vertical = "vsplit",
    horizontal = "split",
    tab = "tabedit",
    default = "edit",
  }
  local edit_buf_cmd_map = {
    vertical = "vert sbuffer",
    horizontal = "sbuffer",
    tab = "tab sbuffer",
    default = "buffer",
  }
  local picker = action_state.get_current_picker(prompt_bufnr)
  local multi_selection = picker:get_multi_selection()

  if #multi_selection > 1 then
    require("telescope.pickers").on_close_prompt(prompt_bufnr)
    pcall(vim.api.nvim_set_current_win, picker.original_win_id)

    for i, entry in ipairs(multi_selection) do
      local filename, row, col

      if entry.path or entry.filename then
        filename = entry.path or entry.filename

        row = entry.row or entry.lnum
        col = vim.F.if_nil(entry.col, 1)
      elseif not entry.bufnr then
        local value = entry.value
        if not value then
          return
        end

        if type(value) == "table" then
          value = entry.display
        end

        local sections = vim.split(value, ":")

        filename = sections[1]
        row = tonumber(sections[2])
        col = tonumber(sections[3])
      end

      local entry_bufnr = entry.bufnr

      if entry_bufnr then
        if not vim.api.nvim_buf_get_option(entry_bufnr, "buflisted") then
          vim.api.nvim_buf_set_option(entry_bufnr, "buflisted", true)
        end
        local command = i == 1 and "buffer" or edit_buf_cmd_map[method]
        pcall(vim.cmd, string.format("%s %s", command, vim.api.nvim_buf_get_name(entry_bufnr)))
      else
        local command = i == 1 and "edit" or edit_file_cmd_map[method]
        if vim.api.nvim_buf_get_name(0) ~= filename or command ~= "edit" then
          filename = require("plenary.path"):new(vim.fn.fnameescape(filename)):normalize(vim.loop.cwd())
          pcall(vim.cmd, string.format("%s %s", command, filename))
        end
      end

      if row and col then
        pcall(vim.api.nvim_win_set_cursor, 0, { row, col })
      end
    end
  else
    actions["select_" .. method](prompt_bufnr)
  end
end

local custom_actions = transform_mod({
    multi_selection_open_vertical = function(prompt_bufnr)
        multiopen(prompt_bufnr, "vertical")
    end,
    multi_selection_open_horizontal = function(prompt_bufnr)
        multiopen(prompt_bufnr, "horizontal")
    end,
    multi_selection_open_tab = function(prompt_bufnr)
        multiopen(prompt_bufnr, "tab")
    end,
    multi_selection_open = function(prompt_bufnr)
        multiopen(prompt_bufnr, "default")
    end,
})

local function stopinsert(callback)
    return function(prompt_bufnr)
        vim.cmd.stopinsert()
        vim.schedule(function()
            callback(prompt_bufnr)
        end)
    end
end

local multi_open_mappings = {
  i = {
    ["<M-v>"] = stopinsert(custom_actions.multi_selection_open_vertical),
    ["<M-s>"] = stopinsert(custom_actions.multi_selection_open_horizontal),
    ["<M-t>"] = stopinsert(custom_actions.multi_selection_open_tab),
    ["<CR>"]  = stopinsert(custom_actions.multi_selection_open),
  },
  n = {
    ["<M-v>"] = custom_actions.multi_selection_open_vertical,
    ["<M-s>"] = custom_actions.multi_selection_open_horizontal,
    ["<M-t>"] = custom_actions.multi_selection_open_tab,
    ["<CR>"] = custom_actions.multi_selection_open,
  },
}

telescope.setup {
  defaults = {
    mappings = {
      i = {
        ["<C-j>"] = actions.move_selection_next,
        ["<C-k>"] = actions.move_selection_previous,
        ["<C-u>"] = actions.results_scrolling_up,
        ["<C-d>"] = actions.results_scrolling_down,
        ["<C-f>"] = actions.preview_scrolling_down,
        ["<C-b>"] = actions.preview_scrolling_up,
        ["<M-p>"] = action_layout.toggle_preview,
      },
      n = {
        ["j"] = actions.move_selection_next,
        ["k"] = actions.move_selection_previous,
        ["<C-u>"] = actions.results_scrolling_up,
        ["<C-d>"] = actions.results_scrolling_down,
        ["<C-f>"] = actions.preview_scrolling_down,
        ["<C-b>"] = actions.preview_scrolling_up,
        ["<M-p>"] = action_layout.toggle_preview,
      },
    },
    vimgrep_arguments = {
      'rg',
      '--no-heading',
      '--with-filename',
      '--line-number',
      '--column',
      '--hidden',
      '--smart-case',
      '--glob',
      '!**/node_modules/*',
      '--glob',
      '!**/.git/*',
      '--glob',
      '!.gitignore',
      '--glob',
      '!**/.venv/*',
      '--glob',
      '!**/*.lock',
      '--trim',
    },
    file_ignore_patterns = {"^node_modules/", "^./.git/", "^./.venv/"},
  },
  pickers = {
    find_files = {
      find_command = {
        'rg',
        '--files',
        '--hidden',
        '--smart-case',
        '--glob',
        '!**/node_modules/*',
        '--glob',
        '!**/.git/*',
        '--glob',
        '!**/.venv/*',
      },
      mappings = {
        i = {
          ["<M-v>"] = stopinsert(custom_actions.multi_selection_open_vertical),
          ["<M-s>"] = stopinsert(custom_actions.multi_selection_open_horizontal),
          ["<M-t>"] = stopinsert(custom_actions.multi_selection_open_tab),
          ["<CR>"]  = stopinsert(custom_actions.multi_selection_open),
        },
        n = {
          ["<M-v>"] = custom_actions.multi_selection_open_vertical,
          ["<M-s>"] = custom_actions.multi_selection_open_horizontal,
          ["<M-t>"] = custom_actions.multi_selection_open_tab,
          ["<CR>"] = custom_actions.multi_selection_open,
          ["cd"] = function(prompt_bufnr)
            local selection = require("telescope.actions.state").get_selected_entry()
            local dir = vim.fn.fnamemodify(selection.path, ":p:h")
            require("telescope.actions").close(prompt_bufnr)
            vim.cmd(string.format("silent cd %s", dir))
            vim.cmd(":Telescope find_files")
          end
        },
      },
    },
    buffers = {
        sort_mru = true,
        mappings = multi_open_mappings,
    },
    live_grep = {
        mappings = multi_open_mappings,
    },
  },
  extensions = {
    fzf = {
      fuzzy = true,
      override_generic_sorter = true,
      override_file_sorter = true,
      case_mode = "smart_case",
    },
    file_browser = {
      -- theme = "ivy",
      hidden = true,
      hijack_netrw = true,
      mappings = {
        i = {
          ["<M-v>"] = stopinsert(custom_actions.multi_selection_open_vertical),
          ["<M-s>"] = stopinsert(custom_actions.multi_selection_open_horizontal),
          ["<M-t>"] = stopinsert(custom_actions.multi_selection_open_tab),
          ["<CR>"]  = stopinsert(custom_actions.multi_selection_open),
          ["<M-h>"] = fb_actions.goto_parent_dir,
          ["<M-.>"] = fb_actions.toggle_hidden,
          ["<M-p>"] = fb_actions.change_cwd,
        },
        n = {
          ["<M-v>"] = custom_actions.multi_selection_open_vertical,
          ["<M-s>"] = custom_actions.multi_selection_open_horizontal,
          ["<M-t>"] = custom_actions.multi_selection_open_tab,
          ["<CR>"] = custom_actions.multi_selection_open,
          ["<M-h>"] = fb_actions.goto_parent_dir,
          ["<M-.>"] = fb_actions.toggle_hidden,
          ["<M-p>"] = fb_actions.change_cwd,
        },
      },
    },
    coc = {
      -- theme = 'ivy',
      prefer_locations = true,
    },
    frecency = {
        show_scores = false,
        show_unindexed = true,
        db_safe_mode = false,
    },
  },
}

telescope.load_extension('fzf')
telescope.load_extension('frecency')
telescope.load_extension('file_browser')
telescope.load_extension('ui-select')
telescope.load_extension('ultisnips')

EOF
'''

[[plugins]] # enable to do git operation in vim
repo = 'tpope/vim-fugitive'
on_event = 'VimEnter'
hook_add = '''
nnoremap [git]  <Nop>
nmap <Leader>g [git]
nnoremap <silent> [git]s :Git status<CR><C-w>T
nnoremap <silent> [git]a :Git write<CR>
nnoremap <silent> [git]c :Git commit<CR>
nnoremap <silent> [git]b :Git blame<CR>
nnoremap <silent> [git]d :Git diff<CR>
nnoremap <silent> [git]m :Git merge<CR>
'''

[[plugins]] # git-messenger shows message from last commit
repo = 'rhysd/git-messenger.vim'
on_event = 'BufReadPost'
hook_add = '''
let g:git_messenger_no_default_mappings=v:true
nnoremap <silent> [git]gm :GitMessenger<CR>
'''

[[plugins]]
repo = 'sindrets/diffview.nvim'
depends = ['nvim-web-devicons']
on_event = 'BufReadPost'
hook_post_source = '''
lua << EOF

require("diffview").setup({
  use_icons = false,
})

EOF

nnoremap <silent> [git]d :DiffviewOpen<CR>
'''

[[plugins]] # hunk changed contents
repo = 'lewis6991/gitsigns.nvim'
on_event = 'VimEnter'
hook_post_source = '''
lua << EOF

require("gitsigns").setup({
  on_attach = function(bufnr)
    local gs = package.loaded.gitsigns

    local function map(mode, l, r, opts)
      opts = opts or {}
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    -- Navigation
    map('n', ']h', function()
      if vim.wo.diff then return ']h' end
      vim.schedule(function() gs.next_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    map('n', '[h', function()
      if vim.wo.diff then return '[h' end
      vim.schedule(function() gs.prev_hunk() end)
      return '<Ignore>'
    end, {expr=true})

    -- Actions
    map({'n', 'v'}, '<leader>hs', ':Gitsigns stage_hunk<CR>')
    map({'n', 'v'}, '<leader>hr', ':Gitsigns reset_hunk<CR>')
    map('n', '<leader>hS', gs.stage_buffer)
    map('n', '<leader>hu', gs.undo_stage_hunk)
    map('n', '<leader>hR', gs.reset_buffer)
    map('n', '<leader>hp', gs.preview_hunk)
    map('n', '<leader>hb', function() gs.blame_line{full=true} end)
    map('n', '<leader>hd', gs.diffthis)
    map('n', '<leader>hD', function() gs.diffthis('~') end)
    map('n', '<leader>hw', ':Gitsigns toggle_word_diff<CR>')
    map('n', '<leader>ht', gs.toggle_deleted)
  end
})

EOF
'''

[[plugins]]
repo = 'rlane/pounce.nvim'
on_event = 'BufReadPost'
hook_add = '''
noremap [motion] <Nop>
map <S-m> [motion]

nmap [motion] <cmd>Pounce <CR>
vmap [motion] <cmd>Pounce <CR>
omap [motion] <cmd>Pounce <CR>
'''
hook_post_source = '''
lua << EOF

require("pounce").setup({
  accept_keys = "JFKDLSAHGNUVRBYTMICEOXWPQZ",
  accept_best_key = "<enter>",
  multi_window = true,
  debug = false,
})

EOF
'''

# [[plugins]] # Auto close parentheses
# repo = 'cohama/lexima.vim'
# on_event = 'VimEnter'
# hook_add = '''
# "call lexima#add_rule({'char': '$', 'input_after': '$', 'filetype': 'latex'})
# "call lexima#add_rule({'char': '$', 'at': '\%#\$', 'leave': 1, 'filetype': 'latex'})
# "call lexima#add_rule({'char': '<BS>', 'at': '\$\%#\$', 'delete': 1, 'filetype': 'latex'})
# '''

[[plugins]] # enable to buffer execution on vim
repo = 'thinca/vim-quickrun'
on_event = 'VimEnter'
hook_add = '''
let g:quickrun_config = get(g:, 'quickrun_config', {})
let g:quickrun_config._ = {
      \ 'runner' : 'vimproc',
      \ 'outputter/buffer/split' : ':botright 8sp',
      \ 'outputter' : 'error',
      \ 'outputter/error/success' : 'buffer',
      \ 'outputter/error/error' : 'quickfix',
      \ 'outputter/buffer/close_on_empty' : 1,
      \ }

let g:quickrun_config.rust = {
      \ 'exec' : 'cargo run',
      \ }

let g:quickrun_config.go = {
      \ 'exec' : 'go run .',
      \ }

let g:quickrun_no_default_key_mappings = 1

nnoremap <Leader>r :cclose<CR>:write<CR>:QuickRun<CR>
xnoremap <Leader>r :<C-U>cclose<CR>:write<CR>gv:QuickRun -mode v<CR>

autocmd FileType qf nnoremap <silent><buffer>q :quit<CR>

" \r: save and execute quickrun (excluding go file type)
" autocmd Filetype * if &ft!="go"|nnoremap <buffer> <Leader>r :cclose<CR>:write<CR>:QuickRun -mode n<CR>|endif

" nnoremap \r :cclose<CR>:write<CR>:QuickRun -mode n<CR>
" xnoremap \r :<C-U>cclose<CR>:write<CR>gv:QuickRun -mode v<CR>

" C-c: stop quickrun
nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "<Leader><C-c>"
'''

# [[plugins]] # Neovim/Vim integration for Delve
# repo = 'sebdah/vim-delve'
# on_event = 'VimEnter'
# on_ft = 'go'
# hook_add = '''
# autocmd FileType go nnoremap <Leader>d :DlvDebug<CR>
# autocmd FileType go nnoremap <Leader>p :DlvToggleBreakpoint<CR>
# '''

[[plugins]] # get file type for Shougo-san's plugins
repo = 'Shougo/context_filetype.vim'
on_event = 'BufEnter'

[[plugins]] # swhitch buffer file type according to cursor position
repo = 'osyo-manga/vim-precious'
depends = ['context_filetype.vim']
on_event = 'BufEnter'
hook_add ='''
'''

[[plugins]] # enhance text object
repo = 'tpope/vim-surround'
on_event = 'BufReadPost'

[[plugins]] # highlights trailing whitespace
repo = 'bronson/vim-trailing-whitespace'
on_event = 'VimEnter'
hook_add = '''
let g:extra_whitespace_ignored_filetypes = [
            \ 'help',
            \ 'diff',
            \ 'TelescopePrompt',
            \ 'Telescope'
            \ ]
autocmd BufWritePre * :FixWhitespace
'''

[[plugins]] # plugin for alignment words
repo = 'h1mesuke/vim-alignta'
on_event = 'BufEnter'
on_cmd = 'Alignta'

[[plugins]] # a plugin for using web-api in vim
repo = 'mattn/webapi-vim'

[[plugins]] # for using gist services
repo = 'mattn/gist-vim'
depends = ['webapi-vim']
on_cmd = 'Gist'

[[plugins]]
repo = 'lukas-reineke/indent-blankline.nvim'
on_event = 'VimEnter'
hook_post_source = '''
lua << EOF

vim.opt.listchars:append "space:â‹…"
vim.opt.listchars:append "eol:â†´"

require("ibl").setup {
    scope = {
        show_start = false,
        show_end = false,
    },
}

EOF
'''

[[plugins]] # auto insert space around '=' & ','
repo = 'kana/vim-smartchr'
on_event = 'InsertCharPre'
hook_add = '''
" inoremap <expr> , smartchr#loop(', ', ',')
" inoremap <expr> . smartchr#loop('.', '. ', '..', '...')
inoremap <expr> = smartchr#loop('=', ' = ', ' == ', ' === ')
" inoremap <expr> ! smartchr#loop('!', '!!', ' != ')
" inoremap <expr> : smartchr#loop(':', '::', ' := ')
" inoremap <expr> + smartchr#loop('+', ' + ', '++')
" inoremap <expr> - smartchr#loop('-', ' - ', '--')
" inoremap <expr> * smartchr#loop('*', ' * ')
" inoremap <expr> / smartchr#loop('/', ' / ', '// ')
" inoremap <expr> & smartchr#loop('&', ' & ', ' && ')
" inoremap <expr> | smartchr#loop('|', ' | ', ' || ')
'''

[[plugins]] # comment out / decomment plugin
repo = 'numToStr/Comment.nvim'
on_event = 'BufReadPre'
hook_post_source = '''
lua << EOF

require('Comment').setup({
  mappings = {
    basic = true,
    extra = true,
  }
})

EOF
'''

[[plugins]] # for enabling display & edit binary file in vim
repo = 'Shougo/vinarise.vim'
on_cmd = 'Vinarise'
hook_add = 'let g:vinarise_enable_auto_detect = 1'

[[plugins]] # for url open in browser & search word
repo = 'tyru/open-browser.vim'
on_map = ['<Plug>(openbrowser-smart-search)']
on_event = 'BufEnter'
hook_add = '''
nmap gs <Plug>(openbrowser-smart-search)
vmap gs <Plug>(openbrowser-smart-search)
'''

[[plugins]] # for the real-time preview for markdown files
repo = 'iamcco/markdown-preview.nvim'
on_ft = ['markdown','pandoc.markdown','rmd']
build = 'sh -c "cd app && yarn install"'

[[plugins]] # assist table edit on markdown files
repo = 'dhruvasagar/vim-table-mode'
on_ft = ['markdown','pandoc.markdown','rmd']
on_event = 'BufReadPost'

[[plugins]] # Automated session manager
repo = 'Shatur/neovim-session-manager'
depends = ['plenary.nvim']
on_event = 'VimEnter'
hook_post_source = '''

lua << EOF

local Path = require('plenary.path')
require('session_manager').setup({
  autoload_mode = require('session_manager.config').AutoloadMode.Disabled, -- Define what to do when Neovim is started without arguments. Possible values: Disabled, CurrentDir, LastSession
  autosave_last_session = true, -- Automatically save last session on exit and on session switch.
  autosave_ignore_not_normal = true, -- Plugin will not save a session when no buffers are opened, or all of them aren't writable or listed.
  autosave_ignore_dirs = {
    "/",
    "~/",
  }, -- A list of directories where the session will not be autosaved.
  autosave_ignore_filetypes = { -- All buffers of these file types will be closed before the session is saved.
    'gitcommit',
  },
  autosave_only_in_session = true, -- Always autosaves session. If true, only autosaves after a session is active.
})

EOF
'''

[[plugins]] # call :Template to get template each file types
repo = 'mattn/sonictemplate-vim'
on_cmd = 'Template'

[[plugins]] # set auto ambiwidth
repo = 'delphinus/cellwidths.nvim'
on_event = 'BufReadPre'
hook_post_source = '''

lua << EOF

require("cellwidths").setup {
  name = "default",
}

EOF
'''

[[plugins]] # EditorConfig
repo = 'editorconfig/editorconfig-vim'
on_event = 'BufReadPre'
on_path = '.*'

[[plugins]] # indent based folding and motion
repo = 'pseewald/vim-anyfold'
on_event = 'BufEnter'
hook_add = '''
filetype plugin indent on
syntax on

" activate anyfold by default
augroup anyfold
    autocmd!
    autocmd Filetype * AnyFoldActivate
augroup END

" disable anyfold for large files
let g:LargeFile = 1000000 " file is large if size greater than 1MB
autocmd BufReadPre,BufRead * let f=getfsize(expand("<afile>")) | if f > g:LargeFile || f == -2 | call LargeFile() | endif
function LargeFile()
    augroup anyfold
        autocmd! " remove AnyFoldActivate
        autocmd Filetype * setlocal foldmethod=indent " fall back to indent folding
    augroup END
endfunction
" autocmd Filetype * AnyFoldActivate

set foldlevel=20
'''

# [[plugins]] # accelerate up-down moving
# repo = 'rhysd/accelerated-jk'
# on_event = 'BufEnter'
# hook_add = '''
# nmap j <Plug>(accelerated_jk_gj)
# nmap k <Plug>(accelerated_jk_gk)
# '''

[[plugins]] # logging command output
repo = 'tyru/capture.vim'
on_event = 'VimEnter'

[[plugins]] # file visualizer
repo = 'nvim-tree/nvim-tree.lua'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local nvim_tree = require("nvim-tree")

nvim_tree.setup()

EOF
'''

[[plugins]] # pretty quickfix, location view
repo = 'yorickpeterse/nvim-pqf'
on_event = "BufEnter"
hook_post_source = '''
lua << EOF

local pqf = require("pqf")

pqf.setup({
})

EOF
'''

[[plugins]] # autopairs
repo = 'windwp/nvim-autopairs'
on_event = "InsertEnter"
depends = ["nvim-cmp"]
hook_post_source = '''
lua << EOF

local npairs = require("nvim-autopairs")

local Rule = require('nvim-autopairs.rule')
local cond = require('nvim-autopairs.conds')
local ts_conds = require('nvim-autopairs.ts-conds')

local cmp_autopairs = require("nvim-autopairs.completion.cmp")
local handlers = require("nvim-autopairs.completion.handlers")

local cmp = require("cmp")

npairs.setup({
  check_ts = true,
  ts_config = {
    -- lua = {'string'},
    -- python = {},
  },
  ignored_next_char = "[%w%.]", -- will ignore alphanumeric and `.` symbol
})

-- add custom rules

npairs.add_rule(Rule("$$","$$","tex"))

-- press % => %% only while inside a comment or string
-- npairs.add_rules({
--   Rule("%", "%", "lua")
--     :with_pair(ts_conds.is_ts_node({'string','comment'})), -- not working in this cond?
--   Rule("$", "$", "lua")
--     :with_pair(ts_conds.is_not_ts_node({'function'}))
-- })


cmp.event:on(
  'confirm_done',
  cmp_autopairs.on_confirm_done({
    filetypes = {
      -- "*" is a alias to all filetypes
      ["*"] = {
        ["("] = {
          kind = {
            cmp.lsp.CompletionItemKind.Function,
            cmp.lsp.CompletionItemKind.Method,
          },
          handler = handlers["*"]
        }
      },
      -- lua = {
      --   ["("] = {
      --     kind = {
      --       cmp.lsp.CompletionItemKind.Function,
      --       cmp.lsp.CompletionItemKind.Method
      --     },
      --     ---@param char string
      --     ---@param item table item completion
      --     ---@param bufnr number buffer number
      --     ---@param rules table
      --     ---@param commit_character table<string>
      --     handler = function(char, item, bufnr, rules, commit_character)
      --       -- Your handler function. Inspect with print(vim.inspect{char, item, bufnr, rules, commit_character})
      --     end
      --   }
      -- },
      -- Disable for tex
      tex = false,
      text = false,
    }
  })
)

EOF
'''

[[plugins]] # git conflict support plugin
repo = 'akinsho/git-conflict.nvim'
rev = "v*"
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

require("git-conflict").setup()

EOF
'''

[[plugins]] # jump outlines
repo = 'hedyhli/outline.nvim'
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

require("outline").setup({
  symbol_folding = {
    auto_unfold = {
      only = 2,
    },
  },
  preview_window = {
    auto_preview = true,
  },
})

EOF

" set outline.nvim keymap as a part of Telescope commands
nmap <C-p> [telescope]
nnoremap <silent> [telescope]h :Outline<CR>

'''

[[plugins]] # jump outlines
repo = 'nvimdev/lspsaga.nvim'
on_event = "VimEnter"
depends = ['nvim-treesitter', 'nvim-web-devicons']
hook_post_source = '''
lua << EOF

require("lspsaga").setup({
  symbol_in_winbar = {
    enable = false,
    show_server_name = false,
    show_file = false,
  },
  finder = {
    enable = false,
  },
  code_action = {
    extend_gitsigns = true,
  },
  lightbulb = {
    enable = false,
  },
})

-- add lspsaga keymaps instead of native lsp functions
vim.keymap.set('n', 'gd', "<cmd>Lspsaga peek_definition<CR>", opts)
vim.keymap.set('n', '[lsp]n', "<cmd>Lspsaga diagnostic_jump_next<CR>", opts)
vim.keymap.set('n', '[lsp]p', "<cmd>Lspsaga diagnostic_jump_prev<CR>", opts)
vim.keymap.set('n', '[lsp]d', "<cmd>Lspsaga show_buf_diagnostics<CR>", opts)
vim.keymap.set('n', '[lsp]wd', "<cmd>Lspsaga show_workspace_diagnostics<CR>", opts)
vim.keymap.set('n', '[lsp]h', "<cmd>Lspsaga hover_doc<CR>", opts)
vim.keymap.set('n', '[lsp]a', "<cmd>Lspsaga code_action<CR>", opts)
vim.keymap.set('n', '[lsp]r', "<cmd>Lspsaga rename<CR>", opts)
vim.keymap.set('n', '[lsp]F', "<cmd>Lspsaga finder<CR>", opts)

EOF

'''

[[plugins]] # make a bookmarks
repo = 'tomasky/bookmarks.nvim'
on_event = "BufReadPre"
depends = ['telescope.nvim']
hook_source = '''

nnoremap [bookmark]  <Nop>
nmap <S-b> [bookmark]

lua << EOF

require("bookmarks").setup({
  sign_priority = 8,  --set bookmark sign priority to cover other sign
  save_file = vim.fn.expand "$HOME/.config/nvim/bookmarks", -- bookmarks save file path
  keywords =  {
    ["@t"] = "ðŸ”–", -- mark annotation startswith @t,signs this icon as `Todo`
    ["@w"] = "ðŸš§" , -- mark annotation startswith @w arn,signs this icon as `Warn`
    ["@f"] = "ðŸ§°", -- mark annotation startswith @f ix,signs this icon as `Fix`
    ["@n"] = "ðŸ“–" , -- mark annotation startswith @n ote,signs this icon as `Note`
  },
  on_attach = function(bufnr)
    local bm = require "bookmarks"
    local map = vim.keymap.set
    map("n","[bookmark]t",bm.bookmark_toggle) -- add or remove bookmark at current line
    map("n","[bookmark]a",bm.bookmark_ann) -- add or edit mark annotation at current line
    map("n","[bookmark]e",bm.bookmark_ann) -- add or edit mark annotation at current line
    map("n","[bookmark]c",bm.bookmark_clean) -- clean all marks in local buffer
    map("n","[bookmark]n",bm.bookmark_next) -- jump to next mark in local buffer
    map("n","[bookmark]p",bm.bookmark_prev) -- jump to previous mark in local buffer
    map("n","[bookmark]l",bm.bookmark_list) -- show marked file list in quickfix window
  end
})

require('telescope').load_extension('bookmarks')

EOF

" set keymaps
nnoremap <silent> [bookmark]t :Git status<CR><C-w>T
nnoremap <silent> [bookmark]e :Git write<CR>

nnoremap <silent> [telescope]B :Telescope bookmarks list <CR>
'''

[[plugins]] # showin top bar
repo = 'akinsho/bufferline.nvim'
rev = "v4.*"
on_event = "VimEnter"
depends = ['nvim-web-devicons']
hook_post_source = '''
lua << EOF

local bufferline = require("bufferline")

bufferline.setup({
  options = {
    style_preet = bufferline.style_preset.minimal,
    diagnostics = "nvim_lsp",
    diagnostics_indicator = function(count, level, diagnostics_dict, context)
      local icon = "ïœ "
      if level:match("error") then
        return " " .. icon .. count
      elseif level:match("warn") then
        icon = "ï± "
        return " " .. icon .. count
      elseif level:match("info") then
        icon = "î©´ "
        return " " .. icon .. count
      elseif level:match("hint") then
        icon = "ï€ "
        return " " .. icon .. count
      end
      local icon = level:match("error") and "ïœ " or "ï± "
      return " " .. icon .. count
    end,
  },
})

EOF
'''

[[plugins]] # highlight any words
repo = 't9md/vim-quickhl'
on_event = "BufReadPre"
hook_add = '''
nmap <Leader>hl <Plug>(quickhl-manual-this)
xmap <Leader>hl <Plug>(quickhl-manual-this)
nmap <Leader>hc <Plug>(quickhl-manual-reset)
xmap <Leader>hc <Plug>(quickhl-manual-reset)

'''

[[plugins]] # highlight todo comments
repo = 'folke/todo-comments.nvim'
rev = "v1.*"
depends = ['plenary.nvim']
on_event = "VimEnter"
hook_post_source = '''
lua << EOF

local c = require('onedark.colors')

require("todo-comments").setup({
  colors = {
    error = { c.red },
    warning = { c.yellow },
    info = { c.blue },
    hint = { c.green },
    default = {  c.green },
    test = {  c.purple }
  },
})

vim.keymap.set("n", "]t", function()
  require("todo-comments").jump_next()
end, { desc = "Next todo comment" })

vim.keymap.set("n", "[t", function()
  require("todo-comments").jump_prev()
end, { desc = "Previous todo comment" })

EOF
'''

[[plugins]] # ChatGPT frontend for Neovim
repo = 'jackMort/ChatGPT.nvim'
on_event = "VimEnter"
depends = ['plenary.nvim', 'nui.nvim', 'telescope.nvim']
hook_post_source = '''
lua << EOF

local chatgpt = require("chatgpt")

chatgpt.setup({
    openai_params = {
        model = "gpt-3.5-turbo",
        max_tokens = 350,
    }
})

EOF
'''

[[plugins]] # calculating startup time
repo = 'dstein64/vim-startuptime'
on_event = "VimEnter"
